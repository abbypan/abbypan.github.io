---
layout: post
category: tech
title:  "Zero Knowledge Proofs"
tagline: ""
tags: [ "zkp", "nizk", "zcash", "zksnark", "bitcoin", "bulletproofs" ] 
---
{% include JB/setup %}

* TOC
{:toc}

# MOOC: Zero Knowledge Proofs

[MOOC: Zero Knowledge Proofs](https://zk-learning.org/)

## Lecture 2 Dan Boneh: Introduction to Modern SNARKs

zk-SNARK: Zero-knowledge a Succinct ARgument of Knowledge

setup for circuit C: 
- trusted setup per circuit: `S(C; r) -> (pp, vp)`, secret r
- trusted but universal setup: `Sinit(λ; r) -> gp`, secret r 仅初始化一次; Sindex(gp, C) -> (pp, vp),  per circuit
- transparent setup: `S(C) -> (pp, vp)`

SNARK (S, P, V)
- `S(C) -> (pp, vp), public parameters`
- `P(pp, x, w) -> π, proof`
- `V(vp, x, π) -> accept/reject`

functional commitment
- `setup(1^λ) -> gp`
- `commit(gp, f, r) -> comf`, r为random, f为function
    - polinomial
    - multilinear
    - vector
    - inner product arguments (IPA)
- eval(P, V): `P(gp, f, x, y, r) -> π,  V(gp, comf, x, y, π) -> accept/reject`

interactive oracle proof (IOP)

## Lecture 5 Dan Boneh: The Plonk SNARK

Poly-IOP: Zero Test, Sum Check, Prod Check, Permutation Check

PLONK: a poly-IOP for a general circuit `𝐶(𝑥, 𝑤)`，构造input, gate, wiring, output的check，使用lagrange & FFT

## Lecture 6 Yupeng Zhang: Polynomial Commitments based on Pairing and Discrete Logarithm

Univariate KZG, Multivariate KZG, ...

Bulletproofs

# KZG10

[KZG10: Constant-Size Commitments to Polynomials and Their Applications](https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf)

universal polynomial φ(x)的取值作为g的幂次，同等变换为，polynomial φ(x)的coffients做为PK里的g^(α^i)的幂次

再结合pairing求解


    Trusted Setup:
    bilinear pairing group GG = 〈e, G, Gt〉

    SK = Random α, PK =〈GG, g, g^α, . . . , g^(α^t) 〉

    polynomial φ(x) ∈ Zp[x] 
    φ(x) = ∑ φj * x^j,  0<= j <=deg(φ), deg(φ) <= t

    Commit(PK, φ(x)): 

    commit C  = g^φ(α) 
              = g^(∑ φj * x^j) 
              = ∏ g^(φj * α^j)
              = ∏ (g^(a^j))^φj

    Open(PK, C, φ(x)): φ(x)

    VerifyPoly(PK, C, φ(x)):
    verify C == ∏ (g^(a^j))^φj

    CreateWitness(PK, φ(x), i):

    ψi(x) = (φ(x)−φ(i))/(x−i), 
    proof wi = g^ψi(α)
    output 〈i, φ(i), wi〉

    VerifyEval(PK, C, i, φ(i), wi):

    verify e(C, g) == e(wi, g^α/g^i) * e(g, g)^φ(i)

    e(wi, g^α/g^i) * e(g, g)^φ(i)
    = e(g^ψi(α) , g^(α-i)) * e(g^φ(i), g)
    = e(g^(ψi(α) * (α-i)), g) * e(g^φ(i), g)
    = e(g^(φ(α)−φ(i)), g) * e(g^φ(i), g)
    = e(g^φ(α), g)
    = e(C, g)

Batch Opening 针对多个i聚合运算

    CreateWitnessBatch(PK, φ(x), B): 〈B, r(x), wB 〉
    B ⊂ Zp
    r(x) = φ(x) % ∏ (x-i), i∈B
    ψB(x) = (φ(x)−r(x))/ ∏ (x-i), i∈B
    wB = g^ψB(α)

    VerifyEvalBatch(PK, C, B, r(x), wB ): i∈B
    verify e(C, g) == e(g^∏ (α−i), wB ) * e(g, g^r(α))
    verify r(i) == φ(i)

# Groth16

[Groth16: On the Size of Pairing-based Non-interactive Arguments](https://eprint.iacr.org/2016/260.pdf)

[Groth16 zkSNARK: R1CS and QAP - From Zero to Hero with Finite Fields & sagemath](https://risencrypto.github.io/R1CSQAP/)

[Groth16](http://www.zeroknowledgeblog.com/index.php/groth16)

[The Mathematical Mechanics Behind the Groth16 Zero-knowledge Proving Protocol](https://kayleegeorge.github.io/math110_WIM.pdf)

## R1CS: rank-1 constraint system

- 假设共m个Gate。
- 将Gate运算的variable按顺序排列，S中的每一列对应每个variable在某个输入的取值statement x。
- 将Gate运算公式转换为约束matrix：A中的每一行为left input，B中的每一行为right input，C中的每一行为output。

## QAP

- 对A/B/C的每一列，以`(row_i, value)`为point计算lagrange多项式，获得转置后的lagrange系数多项式matrix，对应ui(x), vi(x), wi(x)。
- S 与 上述lagrange matrix点乘，获得A/B/C对应的多项式A(x), B(x), C(x)，计算

    T(x) = A(x) * B(x) - C(x)
    Z(x) = (x - 1) * ... * (x - m)
    H(x) = T(x) / Z(x)

显然，`T(x) = H(x) * Z(x)`

## NIZK

见 3.2 NIZK arguments for quadratic arithmetic programs

pairing-friendly elliptic curves

    a0 = 1
    public statements (a1, ..., al)
    secret witnesses (al+1, ..., am)

    ∑ ai*ui(x) · ∑ ai*vi(x) = ∑ ai*wi(X) + h(X)t(X),  i = 0, ..., m

    Setup(R): 
    τ = (α, β, γ, δ, x)
    σ1 = ( α, β, δ, 
        {x^i} 0<=i<=n−1, 
        { (β*ui(x)+α*vi(x)+wi(x))/γ } 0<=i<=l, 
        { (β*ui(x)+α*vi(x)+wi(x))/δ } l+1<=i<=m, 
        { (x^i * t(x))/δ } 0<=i<=n-2
    )
    σ2 = ( β, γ, δ, 
        {x^i} 0<=i<=n-1
    )
    σ = ([σ1]1, [σ2]2)

    Prove:
    π ← Prove(R, σ, a1, . . . , am)
    r, s ← Zp
    A = α + ∑ ai*ui(x) + rδ,  0<=i<=m
    B = β + ∑ ai*vi(x) + sδ,  0<=i<=m
    C = ( ∑ ai*( β*ui(x) + α*vi(x) + wi(x)) + h(x)t(x) )/δ + As + Br − rsδ
    π = ([A]1, [C]1, [B]2)

    Verify:
    Vfy(R, σ, a1, . . . , al, π)
    [A]1 · [B]2 = [α]1 · [β]2 + ∑ ai*( (β*ui(x) + α*vi(x) + wi(x))/γ ) · [γ]2 + [C]1 · [δ]2,   0<=i<=l

    Sim:
    π ← Sim(R, τ, a1, . . . , al)
    C = ( AB − αβ − ∑ ai*(β*ui(x) + α*vi(x) + wi(x)) )/δ, i= 0, ..., l  

精简的σV，只需`l+2`个G1 element, 3个G2 element，1个GT element

    σV = ( p, G1, G2, GT , e, [1]1, { [( β*ui(x) + α*vi(x) + wi(x))/γ ]1 }  0<=i<=l, [1]2, [γ]2, [δ]2, [αβ]T )

## security

显然容易继承pairing curve的malleable问题，基本参考校验原文，或者防重放等。

如果关联identity，同时涉及identity的trust。


# Bulletproofs

[BCCGP16: Eﬃcient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting](https://eprint.iacr.org/2016/263.pdf)

[Bulletproofs: Short Proofs for Confidential Transactions and More](https://crypto.stanford.edu/bulletproofs/) 

[Bulletproofs18](https://ieeexplore.ieee.org/document/8418611)

[Bulletproofs17](https://eprint.iacr.org/2017/1066.pdf)




