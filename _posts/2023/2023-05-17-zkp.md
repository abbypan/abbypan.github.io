---
layout: post
category: tech
title:  "Zero Knowledge Proofs"
tagline: ""
tags: [ "zkp", "nizk", "zcash", "zksnark", "bitcoin", "bulletproofs" ] 
---
{% include JB/setup %}

* TOC
{:toc}

# MOOC: Zero Knowledge Proofs

[MOOC: Zero Knowledge Proofs](https://zk-learning.org/)

## Lecture 2 Dan Boneh: Introduction to Modern SNARKs

zk-SNARK: Zero-knowledge a Succinct ARgument of Knowledge

setup for circuit C: 
- trusted setup per circuit: `S(C; r) -> (pp, vp)`, secret r
- trusted but universal setup: `Sinit(Î»; r) -> gp`, secret r ä»…åˆå§‹åŒ–ä¸€æ¬¡; Sindex(gp, C) -> (pp, vp),  per circuit
- transparent setup: `S(C) -> (pp, vp)`

SNARK (S, P, V)
- `S(C) -> (pp, vp), public parameters`
- `P(pp, x, w) -> Ï€, proof`
- `V(vp, x, Ï€) -> accept/reject`

functional commitment
- `setup(1^Î») -> gp`
- `commit(gp, f, r) -> comf`, rä¸ºrandom, fä¸ºfunction
    - polinomial
    - multilinear
    - vector
    - inner product arguments (IPA)
- eval(P, V): `P(gp, f, x, y, r) -> Ï€,  V(gp, comf, x, y, Ï€) -> accept/reject`

interactive oracle proof (IOP)

## Lecture 5 Dan Boneh: The Plonk SNARK

Poly-IOP: Zero Test, Sum Check, Prod Check, Permutation Check

PLONK: a poly-IOP for a general circuit `ğ¶(ğ‘¥, ğ‘¤)`ï¼Œæ„é€ input, gate, wiring, outputçš„checkï¼Œä½¿ç”¨lagrange & FFT

## Lecture 6 Yupeng Zhang: Polynomial Commitments based on Pairing and Discrete Logarithm

Univariate KZG, Multivariate KZG, ...

Bulletproofs

# KZG10

[KZG10: Constant-Size Commitments to Polynomials and Their Applications](https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf)

universal polynomial Ï†(x)çš„å–å€¼ä½œä¸ºgçš„å¹‚æ¬¡ï¼ŒåŒç­‰å˜æ¢ä¸ºï¼Œpolynomial Ï†(x)çš„coffientsåšä¸ºPKé‡Œçš„g^(Î±^i)çš„å¹‚æ¬¡

å†ç»“åˆpairingæ±‚è§£


    Trusted Setup:
    bilinear pairing group GG = ã€ˆe, G, Gtã€‰

    SK = Random Î±, PK =ã€ˆGG, g, g^Î±, . . . , g^(Î±^t) ã€‰

    polynomial Ï†(x) âˆˆ Zp[x] 
    Ï†(x) = âˆ‘ Ï†j * x^j,  0<= j <=deg(Ï†), deg(Ï†) <= t

    Commit(PK, Ï†(x)): 

    commit C  = g^Ï†(Î±) 
              = g^(âˆ‘ Ï†j * x^j) 
              = âˆ g^(Ï†j * Î±^j)
              = âˆ (g^(a^j))^Ï†j

    Open(PK, C, Ï†(x)): Ï†(x)

    VerifyPoly(PK, C, Ï†(x)):
    verify C == âˆ (g^(a^j))^Ï†j

    CreateWitness(PK, Ï†(x), i):

    Ïˆi(x) = (Ï†(x)âˆ’Ï†(i))/(xâˆ’i), 
    proof wi = g^Ïˆi(Î±)
    output ã€ˆi, Ï†(i), wiã€‰

    VerifyEval(PK, C, i, Ï†(i), wi):

    verify e(C, g) == e(wi, g^Î±/g^i) * e(g, g)^Ï†(i)

    e(wi, g^Î±/g^i) * e(g, g)^Ï†(i)
    = e(g^Ïˆi(Î±) , g^(Î±-i)) * e(g^Ï†(i), g)
    = e(g^(Ïˆi(Î±) * (Î±-i)), g) * e(g^Ï†(i), g)
    = e(g^(Ï†(Î±)âˆ’Ï†(i)), g) * e(g^Ï†(i), g)
    = e(g^Ï†(Î±), g)
    = e(C, g)

Batch Opening é’ˆå¯¹å¤šä¸ªièšåˆè¿ç®—

    CreateWitnessBatch(PK, Ï†(x), B): ã€ˆB, r(x), wB ã€‰
    B âŠ‚ Zp
    r(x) = Ï†(x) % âˆ (x-i), iâˆˆB
    ÏˆB(x) = (Ï†(x)âˆ’r(x))/ âˆ (x-i), iâˆˆB
    wB = g^ÏˆB(Î±)

    VerifyEvalBatch(PK, C, B, r(x), wB ): iâˆˆB
    verify e(C, g) == e(g^âˆ (Î±âˆ’i), wB ) * e(g, g^r(Î±))
    verify r(i) == Ï†(i)

# Groth16

[Groth16: On the Size of Pairing-based Non-interactive Arguments](https://eprint.iacr.org/2016/260.pdf)

[Groth16 zkSNARK: R1CS and QAP - From Zero to Hero with Finite Fields & sagemath](https://risencrypto.github.io/R1CSQAP/)

[Groth16](http://www.zeroknowledgeblog.com/index.php/groth16)

[The Mathematical Mechanics Behind the Groth16 Zero-knowledge Proving Protocol](https://kayleegeorge.github.io/math110_WIM.pdf)

## R1CS: rank-1 constraint system

- å‡è®¾å…±mä¸ªGateã€‚
- å°†Gateè¿ç®—çš„variableæŒ‰é¡ºåºæ’åˆ—ï¼ŒSä¸­çš„æ¯ä¸€åˆ—å¯¹åº”æ¯ä¸ªvariableåœ¨æŸä¸ªè¾“å…¥çš„å–å€¼statement xã€‚
- å°†Gateè¿ç®—å…¬å¼è½¬æ¢ä¸ºçº¦æŸmatrixï¼šAä¸­çš„æ¯ä¸€è¡Œä¸ºleft inputï¼ŒBä¸­çš„æ¯ä¸€è¡Œä¸ºright inputï¼ŒCä¸­çš„æ¯ä¸€è¡Œä¸ºoutputã€‚

## QAP

- å¯¹A/B/Cçš„æ¯ä¸€åˆ—ï¼Œä»¥`(row_i, value)`ä¸ºpointè®¡ç®—lagrangeå¤šé¡¹å¼ï¼Œè·å¾—è½¬ç½®åçš„lagrangeç³»æ•°å¤šé¡¹å¼matrixï¼Œå¯¹åº”ui(x), vi(x), wi(x)ã€‚
- S ä¸ ä¸Šè¿°lagrange matrixç‚¹ä¹˜ï¼Œè·å¾—A/B/Cå¯¹åº”çš„å¤šé¡¹å¼A(x), B(x), C(x)ï¼Œè®¡ç®—

    T(x) = A(x) * B(x) - C(x)
    Z(x) = (x - 1) * ... * (x - m)
    H(x) = T(x) / Z(x)

æ˜¾ç„¶ï¼Œ`T(x) = H(x) * Z(x)`

## NIZK

è§ 3.2 NIZK arguments for quadratic arithmetic programs

pairing-friendly elliptic curves

    a0 = 1
    public statements (a1, ..., al)
    secret witnesses (al+1, ..., am)

    âˆ‘ ai*ui(x) Â· âˆ‘ ai*vi(x) = âˆ‘ ai*wi(X) + h(X)t(X),  i = 0, ..., m

    Setup(R): 
    Ï„ = (Î±, Î², Î³, Î´, x)
    Ïƒ1 = ( Î±, Î², Î´, 
        {x^i} 0<=i<=nâˆ’1, 
        { (Î²*ui(x)+Î±*vi(x)+wi(x))/Î³ } 0<=i<=l, 
        { (Î²*ui(x)+Î±*vi(x)+wi(x))/Î´ } l+1<=i<=m, 
        { (x^i * t(x))/Î´ } 0<=i<=n-2
    )
    Ïƒ2 = ( Î², Î³, Î´, 
        {x^i} 0<=i<=n-1
    )
    Ïƒ = ([Ïƒ1]1, [Ïƒ2]2)

    Prove:
    Ï€ â† Prove(R, Ïƒ, a1, . . . , am)
    r, s â† Zp
    A = Î± + âˆ‘ ai*ui(x) + rÎ´,  0<=i<=m
    B = Î² + âˆ‘ ai*vi(x) + sÎ´,  0<=i<=m
    C = ( âˆ‘ ai*( Î²*ui(x) + Î±*vi(x) + wi(x)) + h(x)t(x) )/Î´ + As + Br âˆ’ rsÎ´
    Ï€ = ([A]1, [C]1, [B]2)

    Verify:
    Vfy(R, Ïƒ, a1, . . . , al, Ï€)
    [A]1 Â· [B]2 = [Î±]1 Â· [Î²]2 + âˆ‘ ai*( (Î²*ui(x) + Î±*vi(x) + wi(x))/Î³ ) Â· [Î³]2 + [C]1 Â· [Î´]2,   0<=i<=l

    Sim:
    Ï€ â† Sim(R, Ï„, a1, . . . , al)
    C = ( AB âˆ’ Î±Î² âˆ’ âˆ‘ ai*(Î²*ui(x) + Î±*vi(x) + wi(x)) )/Î´, i= 0, ..., l  

ç²¾ç®€çš„ÏƒVï¼Œåªéœ€`l+2`ä¸ªG1 element, 3ä¸ªG2 elementï¼Œ1ä¸ªGT element

    ÏƒV = ( p, G1, G2, GT , e, [1]1, { [( Î²*ui(x) + Î±*vi(x) + wi(x))/Î³ ]1 }  0<=i<=l, [1]2, [Î³]2, [Î´]2, [Î±Î²]T )

## security

æ˜¾ç„¶å®¹æ˜“ç»§æ‰¿pairing curveçš„malleableé—®é¢˜ï¼ŒåŸºæœ¬å‚è€ƒæ ¡éªŒåŸæ–‡ï¼Œæˆ–è€…é˜²é‡æ”¾ç­‰ã€‚

å¦‚æœå…³è”identityï¼ŒåŒæ—¶æ¶‰åŠidentityçš„trustã€‚


# Bulletproofs

[BCCGP16: Eï¬ƒcient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting](https://eprint.iacr.org/2016/263.pdf)

[Bulletproofs: Short Proofs for Confidential Transactions and More](https://crypto.stanford.edu/bulletproofs/) 

[Bulletproofs18](https://ieeexplore.ieee.org/document/8418611)

[Bulletproofs17](https://eprint.iacr.org/2017/1066.pdf)




