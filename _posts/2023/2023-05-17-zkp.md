---
layout: post
category: tech
title:  "Zero Knowledge Proofs, ZK-SNARK"
tagline: ""
tags: [ "zkp", "nizk", "zcash", "zksnark", "bitcoin", "bulletproofs" ] 
---
{% include JB/setup %}

* TOC
{:toc}

# MOOC: Zero Knowledge Proofs

[MOOC: Zero Knowledge Proofs](https://zk-learning.org/)

## Lecture 2 Dan Boneh: Introduction to Modern SNARKs

zk-SNARK: Zero-knowledge a Succinct ARgument of Knowledge

setup for circuit C: 
- trusted setup per circuit: `S(C; r) -> (pp, vp)`, secret r
- trusted but universal setup: `Sinit(Î»; r) -> gp`, secret r ä»…åˆå§‹åŒ–ä¸€æ¬¡; Sindex(gp, C) -> (pp, vp),  per circuit
- transparent setup: `S(C) -> (pp, vp)`

SNARK (S, P, V)
- `S(C) -> (pp, vp), public parameters`
- `P(pp, x, w) -> Ï€, proof`
- `V(vp, x, Ï€) -> accept/reject`

functional commitment
- `setup(1^Î») -> gp`
- `commit(gp, f, r) -> comf`, rä¸ºrandom, fä¸ºfunction
    - polinomial
    - multilinear
    - vector
    - inner product arguments (IPA)
- eval(P, V): `P(gp, f, x, y, r) -> Ï€,  V(gp, comf, x, y, Ï€) -> accept/reject`

interactive oracle proof (IOP)

## Lecture 5 Dan Boneh: The Plonk SNARK

Poly-IOP: Zero Test, Sum Check, Prod Check, Permutation Check

PLONK: a poly-IOP for a general circuit `ğ¶(ğ‘¥, ğ‘¤)`ï¼Œæ„é€ input, gate, wiring, outputçš„checkï¼Œä½¿ç”¨lagrange & FFT

## Lecture 6 Yupeng Zhang: Polynomial Commitments based on Pairing and Discrete Logarithm

Univariate KZG, Multivariate KZG, ...

Bulletproofs

# KZG10

[KZG10: Constant-Size Commitments to Polynomials and Their Applications](https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf)

universal polynomial Ï†(x)çš„å–å€¼ä½œä¸ºgçš„å¹‚æ¬¡ï¼ŒåŒç­‰å˜æ¢ä¸ºï¼Œpolynomial Ï†(x)çš„coffientsåšä¸ºPKé‡Œçš„g^(Î±^i)çš„å¹‚æ¬¡

å†ç»“åˆpairingæ±‚è§£


    Trusted Setup:
    bilinear pairing group GG = ã€ˆe, G, Gtã€‰

    SK = Random Î±, PK =ã€ˆGG, g, g^Î±, . . . , g^(Î±^t) ã€‰

    polynomial Ï†(x) âˆˆ Zp[x] 
    Ï†(x) = âˆ‘ Ï†j * x^j,  0<= j <=deg(Ï†), deg(Ï†) <= t

    Commit(PK, Ï†(x)): 

    commit C  = g^Ï†(Î±) 
              = g^(âˆ‘ Ï†j * x^j) 
              = âˆ g^(Ï†j * Î±^j)
              = âˆ (g^(a^j))^Ï†j

    Open(PK, C, Ï†(x)): Ï†(x)

    VerifyPoly(PK, C, Ï†(x)):
    verify C == âˆ (g^(a^j))^Ï†j

    CreateWitness(PK, Ï†(x), i):

    Ïˆi(x) = (Ï†(x)âˆ’Ï†(i))/(xâˆ’i), 
    proof wi = g^Ïˆi(Î±)
    output ã€ˆi, Ï†(i), wiã€‰

    VerifyEval(PK, C, i, Ï†(i), wi):

    verify e(C, g) == e(wi, g^Î±/g^i) * e(g, g)^Ï†(i)

    e(wi, g^Î±/g^i) * e(g, g)^Ï†(i)
    = e(g^Ïˆi(Î±) , g^(Î±-i)) * e(g^Ï†(i), g)
    = e(g^(Ïˆi(Î±) * (Î±-i)), g) * e(g^Ï†(i), g)
    = e(g^(Ï†(Î±)âˆ’Ï†(i)), g) * e(g^Ï†(i), g)
    = e(g^Ï†(Î±), g)
    = e(C, g)

Batch Opening é’ˆå¯¹å¤šä¸ªièšåˆè¿ç®—

    CreateWitnessBatch(PK, Ï†(x), B): ã€ˆB, r(x), wB ã€‰
    B âŠ‚ Zp
    r(x) = Ï†(x) % âˆ (x-i), iâˆˆB
    ÏˆB(x) = (Ï†(x)âˆ’r(x))/ âˆ (x-i), iâˆˆB
    wB = g^ÏˆB(Î±)

    VerifyEvalBatch(PK, C, B, r(x), wB ): iâˆˆB
    verify e(C, g) == e(g^âˆ (Î±âˆ’i), wB ) * e(g, g^r(Î±))
    verify r(i) == Ï†(i)

# Groth16

[Groth16: On the Size of Pairing-based Non-interactive Arguments](https://eprint.iacr.org/2016/260.pdf)

[Groth16 zkSNARK: R1CS and QAP - From Zero to Hero with Finite Fields & sagemath](https://risencrypto.github.io/R1CSQAP/)

[Groth16](http://www.zeroknowledgeblog.com/index.php/groth16)

[The Mathematical Mechanics Behind the Groth16 Zero-knowledge Proving Protocol](https://kayleegeorge.github.io/math110_WIM.pdf)

## R1CS: rank-1 constraint system

- å‡è®¾å…±mä¸ªGateã€‚
- å°†Gateè¿ç®—çš„variableæŒ‰é¡ºåºæ’åˆ—ï¼ŒSä¸­çš„æ¯ä¸€åˆ—å¯¹åº”æ¯ä¸ªvariableåœ¨æŸä¸ªè¾“å…¥çš„å–å€¼statement xã€‚
- å°†Gateè¿ç®—å…¬å¼è½¬æ¢ä¸ºçº¦æŸmatrixï¼šAä¸­çš„æ¯ä¸€è¡Œä¸ºleft inputï¼ŒBä¸­çš„æ¯ä¸€è¡Œä¸ºright inputï¼ŒCä¸­çš„æ¯ä¸€è¡Œä¸ºoutputã€‚

## QAP

- å¯¹A/B/Cçš„æ¯ä¸€åˆ—ï¼Œä»¥`(row_i, value)`ä¸ºpointè®¡ç®—lagrangeå¤šé¡¹å¼ï¼Œè·å¾—è½¬ç½®åçš„lagrangeç³»æ•°å¤šé¡¹å¼matrixï¼Œå¯¹åº”ui(x), vi(x), wi(x)ã€‚
- S ä¸ ä¸Šè¿°lagrange matrixç‚¹ä¹˜ï¼Œè·å¾—A/B/Cå¯¹åº”çš„å¤šé¡¹å¼A(x), B(x), C(x)ï¼Œè®¡ç®—

    T(x) = A(x) * B(x) - C(x)
    Z(x) = (x - 1) * ... * (x - m)
    H(x) = T(x) / Z(x)

æ˜¾ç„¶ï¼Œ`T(x) = H(x) * Z(x)`

## NIZK

è§ 3.2 NIZK arguments for quadratic arithmetic programs

pairing-friendly elliptic curves

    a0 = 1
    public statements (a1, ..., al)
    secret witnesses (al+1, ..., am)

    âˆ‘ ai*ui(x) Â· âˆ‘ ai*vi(x) = âˆ‘ ai*wi(X) + h(X)t(X),  i = 0, ..., m

    Setup(R): 
    Ï„ = (Î±, Î², Î³, Î´, x)
    Ïƒ1 = ( Î±, Î², Î´, 
        {x^i} 0<=i<=nâˆ’1, 
        { (Î²*ui(x)+Î±*vi(x)+wi(x))/Î³ } 0<=i<=l, 
        { (Î²*ui(x)+Î±*vi(x)+wi(x))/Î´ } l+1<=i<=m, 
        { (x^i * t(x))/Î´ } 0<=i<=n-2
    )
    Ïƒ2 = ( Î², Î³, Î´, 
        {x^i} 0<=i<=n-1
    )
    Ïƒ = ([Ïƒ1]1, [Ïƒ2]2)

    Prove:
    Ï€ â† Prove(R, Ïƒ, a1, . . . , am)
    r, s â† Zp
    A = Î± + âˆ‘ ai*ui(x) + rÎ´,  0<=i<=m
    B = Î² + âˆ‘ ai*vi(x) + sÎ´,  0<=i<=m
    C = ( âˆ‘ ai*( Î²*ui(x) + Î±*vi(x) + wi(x)) + h(x)t(x) )/Î´ + As + Br âˆ’ rsÎ´
    Ï€ = ([A]1, [C]1, [B]2)

    Verify:
    Vfy(R, Ïƒ, a1, . . . , al, Ï€)
    [A]1 Â· [B]2 = [Î±]1 Â· [Î²]2 + âˆ‘ ai*( (Î²*ui(x) + Î±*vi(x) + wi(x))/Î³ ) Â· [Î³]2 + [C]1 Â· [Î´]2,   0<=i<=l

    Sim:
    Ï€ â† Sim(R, Ï„, a1, . . . , al)
    C = ( AB âˆ’ Î±Î² âˆ’ âˆ‘ ai*(Î²*ui(x) + Î±*vi(x) + wi(x)) )/Î´, i= 0, ..., l  

ç²¾ç®€çš„ÏƒVï¼Œåªéœ€`l+2`ä¸ªG1 element, 3ä¸ªG2 elementï¼Œ1ä¸ªGT element

    ÏƒV = ( p, G1, G2, GT , e, [1]1, { [( Î²*ui(x) + Î±*vi(x) + wi(x))/Î³ ]1 }  0<=i<=l, [1]2, [Î³]2, [Î´]2, [Î±Î²]T )

## security

æ˜¾ç„¶å®¹æ˜“ç»§æ‰¿pairing curveçš„malleableé—®é¢˜ï¼ŒåŸºæœ¬å‚è€ƒæ ¡éªŒåŸæ–‡ï¼Œæˆ–è€…é˜²é‡æ”¾ç­‰ã€‚

å¦‚æœå…³è”identityï¼ŒåŒæ—¶æ¶‰åŠidentityçš„trustã€‚

# BCCGP16

[BCCGP16: Eï¬ƒcient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting](https://eprint.iacr.org/2016/263.pdf)

## homomorphic commitment
 
     Comck(m0; r0) Â· Comck(m1; r1) = Comck(m0 + m1; r0 + r1)

## Pedersen commitment 

    g, h are group elements
    (m, r) âˆˆ Zp x Zp
    c = g^r * h^m

## Recursive Argument for Inner Product Evaluation

å‡è®¾g vector size ä¸º n

    n = âˆ m_i , 1 <= i <= Âµ

æŒ‰å› å­é¡ºåºåšreduce, ä¾‹å¦‚

å–é¦–ä¸ª`m = m_Âµ`ï¼Œæ‹†åˆ†`g = (g_1, ..., g_m)`, ç›¸å½“äºæ‹†åˆ†æˆ m ä¸ª vector size ä¸º n/m çš„vectors `g_i`ã€‚h, a, b çš„æ‹†åˆ†ä¸gç±»ä¼¼ã€‚


è®¡ç®—

    A_k = âˆ g_i^a_(i+k),  min(m,mâˆ’k) <=i<=max(1,1âˆ’k), k = 1 âˆ’ m, . . . , m âˆ’ 1
    A = g^a = âˆ g_i^a_i,  1<=i<=m


`g_i^a_j`çš„matrixæ–œçº¿å…ƒç´ ç›¸ä¹˜ï¼Œå³ä¸º`A_(j-i)`ï¼Œæ˜¾ç„¶ï¼Œ`A = A_0`ã€‚Bä¸Aç±»ä¼¼ã€‚

    (G, p, g, A, h, B, z, m_Âµ = m, m_Âµâˆ’1 = m', . . . , m_1)

è®¡ç®—

    random challenge x
    g' = âˆ (g_i)^(x^âˆ’i),  1<=i<=m
    A' = âˆ (A_k)^(x^k),   1-m<=k<=m-1
    a' = âˆ‘ a_i*(x^i), 1<=i<=m
    A' = g'^a'

    random challenge x^-1
    h' = âˆ (h_i)^(x^i),  1<=i<=m
    B' = âˆ (B_k)^(x^-k),   1-m<=k<=m-1
    b' = âˆ‘ b_i*(x^-i), 1<=i<=m
    B' = h'^b'

    z_k = âˆ‘ a_i Â· b_(i+k),  min(m,mâˆ’k) <= i <= max(1,1âˆ’k), 1-m<=k<=m-1
    z_0 = z = âˆ‘ a_i Â· b_i,  1 <= i <= m
    z'  = âˆ‘ z_k * x^(-k), 1-m<=k<=m-1

    a' Â· b' = âˆ‘ a_i*(x^i) Â· âˆ‘ b_j*(x^-j)
            = âˆ‘ a_i*(x^i) Â· b_j*(x^-j)
            = âˆ‘ (a_i Â· b_j)*(x^(i-j))
            = âˆ‘ (a_i Â· b_(i+k))*(x^(-k)) , permutation, let j = i+k
            = âˆ‘ z_k * x^(-k)
            = z'

è·å¾—`(G, p, g', A', h', B', z', m_Âµâˆ’1, . . . , m_1)`ï¼Œæ˜¾ç„¶ï¼Œg' vector sizeä¸º`n/m`ï¼Œå¯è¿›ä¸€æ­¥æ‹†åˆ†ä¸º`m' = m_Âµâˆ’1`ä¸ªå­vector sizeã€‚

Recursive Argument, ç›´è‡³`m_1`ã€‚

# Bulletproofs

[Bulletproofs: Short Proofs for Confidential Transactions and More](https://crypto.stanford.edu/bulletproofs/) 

[Bulletproofs17](https://eprint.iacr.org/2017/1066.pdf)

[Bulletproofs18](https://ieeexplore.ieee.org/document/8418611)

##  Improved Inner-Product Argument

ä¸BCCGPæ€è·¯ç±»ä¼¼ï¼Œä¼˜åŒ–ä¸ºæ¯æ¬¡æŠ˜åŠï¼ŒRecursive ARgument log(n) æ¬¡

    g, h âˆˆ G^n
    u, P âˆˆ G
    a, b âˆˆ Zp^n

    n=1: 

    P->V: a, b
    c = a Â· b
    V check P == g^a Â· h^b Â· u^c

    n>1:

    n' = n/2
    (a1, a2) = a, (b1, b2) = b, (g1, g2) = g, (h1, h2) = h
    c = a Â· b = a1 Â· b1 + a2 Â· b2

    CL = a1 Â· b2  âˆˆ Zp
    CR = a2 Â· b1  âˆˆ Zp
    L = g2^a1 Â· h1^b2 Â· u^CL âˆˆ G
    R = g1^a2 Â· h2^b1 Â· u^CR âˆˆ G

    P->V: L, R
    V->P: x âˆˆ Zp*
    
    g' = g1^(x^(-1)) Â· g2^x âˆˆ G^n'
    h' = h1^x Â· h2^(x^(-1)) âˆˆ G^n'
    P' = L^(x^2) Â· P Â· R^(x^(-2)) âˆˆ G

    a' = a1*x + a2*x^(-1) âˆˆ Zp^n' 
    b' = b1*x^(-1) + b2*x âˆˆ Zp^n' 

    c' = a' Â· b'
       = a1 Â· b1 + (a1 Â· b2)*x^2 + (a2 Â· b1)*x^(-2) + a2 Â· b2

    P' = L^(x^2) Â· P Â· R^(x^(-2))

       = (g2^(a1*x^2) Â· h1^(b2*x^2) Â· u^(CL*x^2))
          Â· ((g1^a1 Â· g2^a2) Â· (h1^b1 Â· h2^b2) Â· u^(a Â· b))
          Â· ((g1^(a2*x^(-2)) Â· h2^(b1*x^(-2)) Â· u^(CR*x^(-2))

       = (g1^(a1+a2*x^(-2)) Â· g2^(a2+a1*x^2))
         Â· (h1^(b2*x^2+b1) Â· h2^(b2+b1*x^(-2)))
         Â· u^(CL*x^2+a Â· b+CR*x^(-2))

       =  (g1^(x^(-1)))^(a1*x+a2*x^(-1)) Â· (g2^x)^(a2*x^(-1)+a1*x)
         Â· (h1^x)^(b2*x+b1*x^(-1)) Â· (h2^(x^(-1)))^(b2*x+b1*x^(-1))
         Â· u^((a1 Â· b2)*x^2+a1 Â· b1 + a2 Â· b2+(a2 Â· b1)*x^(-2))

       = g'^a' Â· h'^b Â· u^c'

     get (g', h', u, P', a', b')

æ˜¾ç„¶ï¼Œg'/h'/a'/b' çš„vector sizeæŠ˜åŠ

## Inner-Product Range Proof

    < aL - z * 1^n, y^n Â· (aR + z * 1^n) + z^2 * 2^n >  
    = < aL, y^n Â· (aR + z * 1^n) > 
      + < aL, z^2 * 2^n > 
      + < - z * 1^n, y^n Â· (aR + z * 1^n) >
      - z^3 * <1^n, 2^n>
    =  <aL Â· aR, y^n> + <aL,  y^n Â· z * 1^n>
      + z^2 * <aL, 2^n>
      - z * <1^n, y^n Â· aR>
      - z^2 * <1^n, y^n>
      - z^3 * <1^n, 2^n>
    =  0 + z * <aL, y^n>
      + z^2 * v
      - z * <aR, y^n>
      - z^2 * <1^n, y^n>
      - z^3 * <1^n, 2^n>
    = z * <aL -aR, y^n>   
      + z^2 * v 
      - z^2 * <1^n, y^n>
      - z^3 * <1^n, 2^n>
    = z^2 *v
      + (z - z^2) * <1^n, y^n>
      - z^3 * <1^n, 2^n>
    = z^2 * v 
      + Î´(y, z)

éšè—aLï¼Œå¼•å…¥sLã€sR

Aä¸ºaL/aRçš„commitment, Sä¸ºsL/sRçš„commitment

ç»“åˆInner-Product, aL/aR/sL/sR æ„é€  linear vector polynomials
    
    l(X) = (aL - z * 1^n) + sL Â· X
    r(X) = y^n Â· (aR + z * 1^n + sR Â· X) + z^2 * 2^n 

    t(X) = <l(X), r(X)> = t0 + t1 Â· X + t2 Â· X^2
    æ˜¾ç„¶ï¼Œt0 = z^2 * v + Î´(y, z)

å†æ„é€ æ£€æŸ¥
- t1,t2çš„commitments: T1, T2
- l(x), r(x)çš„commitment: P
- tä¸`<l, r>`ç›¸ç­‰

## Logarithmic Range Proof    

ç»“åˆInner-Product Argument, Inner-Product Range Proofï¼ŒèŠ‚çœ l, rçš„ä¼ è¾“ï¼Œå¯ä¼˜åŒ–ä¸º`2log2(n) + 2` elements

è¾¾åˆ°nçš„Logarithmic

## Aggregating Logarithmic Proofs

æŠŠmä¸ªindivual proof æ‹¼æˆ`n*m`sizeçš„vectorï¼ŒåŒæ ·ç»è¿‡Inner-Productä¼˜åŒ–ï¼Œä»¥åŠLogarithmicçš„çº¦å‡ï¼Œä¼˜åŒ–ä¸º`log2(n*m)+4`element

è¾¾åˆ°mçš„additive

## Non-Interactive Proof through Fiat-Shamir

æŠŠ Inner-Product Range Proof ä¸­çš„ y, z ç”Ÿæˆæ–¹å¼æ”¹ä¸€ä¸‹

## mpc

çœ‹dealer

## Inner-Product Proof for Arithmetic Circuits

æ³¨æ„t2å¯ç›´æ¥è®¡ç®—ï¼Œå› æ­¤ä»…æ„é€ t1, t3, t4, t5, t6çš„commitmentï¼Œç”¨äºæ ¡éªŒt(x)

`h' = h^(y^(-n))`,  æ³¨æ„æ­¤å¤„h', hä¸ºG^n element

å†åŸºäºPæ ¡éªŒl(x), r(x)

# Scalable Zero Knowledge via Cycles of Elliptic Curves

[Scalable Zero Knowledge via Cycles of Elliptic Curves](https://eprint.iacr.org/2014/595.pdf)


# Nova

[Nova: Recursive Zero-Knowledge Arguments from Folding Schemes](https://eprint.iacr.org/2021/370.pdf)

é€šè¿‡incrementally veriï¬able computation (IVC)æ„é€ recursive zk ARgument, å®ç°folding

Relaxed R1CS å°†W, Eå‡æ„é€ ä¸ºwitnessï¼›foldingæ—¶ï¼ŒäºŒè€…å¯¹åº”çš„commitment W', E'ä¹Ÿè¿›è¡Œå¯¹åº”çš„å˜æ¢

Relaxed R1CS:
    A, B, C âˆˆ F^(m x m)

    public scalar u âˆˆ F
    public x âˆˆ F^l
    witness W âˆˆ F^(mâˆ’lâˆ’1)
    Z = (W, x, u)

    Folding:
        E â† E1 + r Â· (AZ1 â—¦ BZ2 + AZ2 â—¦ BZ1 âˆ’ u1CZ2 âˆ’ u2CZ1) + r2 Â· E2
        E âˆˆ F^m

        AZ â—¦ BZ = (u1 + r Â· u2) Â· C(Z1 + rZ2) + E
            =  uCZ + E

        T = AZ1 â—¦ BZ2 + AZ2 â—¦ BZ1 âˆ’ u1CZ2 âˆ’ u2CZ1

        ...


Construction 1:
    E' = Com(ppE , E, rE )
    W' = Com(ppW , W, rW )
    T' = Com(ppE , T, rT )
    å°†2ä¸ªRelaxed R1CS instance/witnessè¿›è¡Œfoldingï¼Œå¾—åˆ°æ–°çš„instance/witness
    instance (E', u, W', x)
    witness (E, rE , W, rW )
