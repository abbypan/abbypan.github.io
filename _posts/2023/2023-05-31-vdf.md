---
layout: post
category: tech
title:  "Verifiable Delay Functions"
tagline: ""
tags: [ "vdf", "crypto", "blockchain", "zkp" ] 
---
{% include JB/setup %}

* TOC
{:toc}

# doc

[VDF research](https://vdfresearch.org/)

[A Survey of Two Verifiable Delay Functions](https://eprint.iacr.org/2018/712.pdf)

[On Verifiable Delay Functions](https://speakerdeck.com/asanso/on-verifiable-delay-functions-vdf-how-to-slow-burning-down-the-planet-verifiably)

è®¡ç®—è€—æ—¶ï¼Œæ ¡éªŒç®€å•ï¼Œå¹¶è¡Œè®¡ç®—ä¸èƒ½æ˜æ˜¾æé€Ÿ

Proofs of sequential work (PoSW)

randomness beacon (unpredictable), multiparty random (not bias), consensus from proof of resources(blockchain, elect/vote)

    Setup pp = (ek, vk)
    (y, ğœ‹) = Eval(ek, x)
    Verify(vk, x, y, ğœ‹)

Correctness, Soundness, Sequentiality, Decodability, Incremental

# Proof of Work

blockchain æ±‚è§£å°äºæŸä¸ªtå€¼çš„ H(nonce, x)


# hidden order groups, RSA

eulerï¼Œ`n = p*q`ï¼Œ`Ï•(n)=(p-1)*(q-1)`

unknown order, åˆ™ä¸ºTime-lock puzzles

trusted setup, small subgroup attack

## Wesolowski

[Wesolowski: Efficient verifiable delay functions](https://eprint.iacr.org/2018/623.pdf)

verfieréšæœºé€‰å®šl, ä¹Ÿå¯æ”¹é€ ä¸ºnizkï¼Œä¾‹å¦‚ç½®`l=next_prime(hash(x, y, T))`

    r = 2^T mod l 
    2^T = m*l + r

    ğœ‹ = x^m 
    y = x^(2^T)

    Verify  y = (ğœ‹^l) * (x^r)

## Pietrzak

[Pietrzak: Simple Verifiable Delay Functions](https://eprint.iacr.org/2018/627.pdf)

QRNæ˜¯Zn ä¸Šçš„äºŒæ¬¡å‰©ä½™çš„`|x|`ç»å¯¹å€¼é›†åˆï¼Œå› æ­¤æ˜¯1/4çš„Znã€‚

é€‰å–çš„cyclic group QRN+ ä¸ QRN åŒæ„ï¼Œxå€¼åœ¨`{âˆ’(n âˆ’ 1)/2, . . . , (n âˆ’ 1)/2}`ä»¥å†…ã€‚

    P: Î¼ = x^(2^(T/2)), y=Î¼^(2^(T/2))
    P->V: y

    P->V: Î¼
    V->P: r
    P: (x', y') = (x^r * Î¼, Î¼^r * y)
    P -> V: (x', y'), T/2
    V: verify y' = x'^(2^(T/2))

# De Feo

[De Feo: Verifiable Delay Functions from Supersingular Isogenies and Pairings](https://eprint.iacr.org/2019/166.pdf)

trusted setup, attackåœ¨äºcurveå†…éƒ¨ç»“æ„

ä¾‹å¦‚bls signatureé€‰ç”¨çš„pairing curveï¼Œæ˜¯åœ¨embedding degree k, characteristic pçš„`F_(p^k)`ä¸Šorderä¸ºNçš„subgroup

X1, X2, Y1, Y2, G çš„orderä¸ºN

Ï†, Ë†Ï† ä¸º E, E' ä¹‹é—´ degree l çš„åŒæ€æ˜ å°„

    Ï† : X1 â†’ Y1 
    eY : Y1 Ã— Y2 â†’ G
    X1 Ã— Y2  -> Y1 Ã— Y2 -> G

    Ë†Ï† : Y2 â†’ X2
    eX : X1 Ã— X2 â†’ G
    X1 Ã— Y2 -> X1 x X2 -> G

    eX (P, Ë†Ï†(Q)) = eY (Ï†(P ), Q)

Pä¸ºX1çš„ç”Ÿæˆå…ƒ

    pp = (N, X1, X2, Y1, Y2, G, eX , eY , P, Ï†(P ))

## supersingular curves over Fp

ç±»ä¼¼CSIDH

supersingular curve E/Fp, order N

E,  ÌƒE åœ¨ Fp2 ä¸Š quadratic twist åŒæ„ï¼Œåˆ†åˆ«å¯¹åº”X2, X1


    u âˆˆ Fp^2 \ Fp, u^2 âˆˆ Fp

    Ï… : E â†’  ÌƒE
        (x, y) â†’ (u^2 * x, u^3 * y)

    X2 = E[N] âˆ©  E(Fp).
    X1 = Ï…^âˆ’1 (  ÌƒE[N] âˆ©   ÌƒE(Fp) )

    Y2 = Eâ€²[N] âˆ© Eâ€²(Fp)
    Y1 = Ï…^âˆ’1 (  ÌƒEâ€²[N] âˆ©  ÌƒEâ€²(Fp))

    isogeny Ï† : E â†’ Eâ€² of degree l^T , å¯¹åº” Ë†Ï†;

    Pä¸ºX1ç”Ÿæˆå…ƒ

    (ek, vk) = (Ë†Ï†, (E, Eâ€², P, Ï†(P)))

    Eval( Ë†Ï†, Q âˆˆ Y2) = Ë†Ï†(Q)

    Verify(E, Eâ€², P, Q, Ï†(P), Ë†Ï†(Q))
    Ë†Ï†(Q) âˆˆ X2
    eN (P, Ë†Ï†(Q)) = eN (Ï†(P), Q).

## supersingular curves over Fp2

    Let Ï€ be the Frobenius endomorphism of E/Fp, the trace map on E/Fp2 is the map

    Tr: E/Fp2 â†’ E/Fp,
         P â†’ P + Ï€(P).

     eN (P, Tr(R)) = eN (P, (1+Ï€)(R)) 
                   = eN ((1âˆ’Ï€)(P), R) 
                   = eN ([2]P, R) 
                   = eN (P, R) ^2

     f : Eâ€²[N] â†’ X2,
         Q â†’ (Tr â—¦ Ë†Ï†)(Q);

     Eval( Ë†Ï†, Q âˆˆ Eâ€²[N]) = (Tr â—¦ Ë†Ï†)(Q)

     Verify(E, Eâ€², P, Q, Ï†(P ), (Tr â—¦ Ë†Ï†)(Q))
     (Tr â—¦ Ë†Ï†)(Q) âˆˆ X2
     eN (P, (Tr â—¦ Ë†Ï†)(Q)) = eN (Ï†(P), Q) ^2

# Univariate permutation polynomials

[Verifiable Delay Functions](https://iacr.org/cryptodb/data/paper.php?pubkey=28858)

`Y âŠ† Fq^n to X âŠ† Fq^m` çš„`injective rational map F = (f1 , ...., fm)`

    fi( Ì„y) = xi for i = 1, ..., m
    fi( Ì„y) = g( Ì„y)/h( Ì„y) = xi
    zi( Ì„y) := g( Ì„y)âˆ’xi*h( Ì„y) = 0

## Rational functions on finite fields

æœ‰é™åŸŸä¸Šæ±‚æ ¹

    F(X) = g(X)/h(X)
    GCD(X^q âˆ’ X, g(X) âˆ’ c Â· h(X))
    outputs X âˆ’ s for the unique s such that F(s) = c

## Rational maps on elliptic curves

æ›²çº¿ä¸Šæ±‚å…¬å…±ç‚¹

    E(y, x) = y^2 âˆ’ x^3 âˆ’ ax âˆ’ b
    R = Res_y (z1 , z2) is a univariate polynomial in x of degree deg(z1) Â· deg(z2) such that R(x) = 0
    R â€²= Res_y (R, E)

## weaker VDF

åŸºäºGCD/Resæ±‚è§£çš„å›°éš¾åº¦

    Setup(Î», t): choose a (q, F, X , Y) âˆˆ F specified by Î» and t, and output pp := ((q, F ), (q, F )).

    Eval((q, F),  Ì„x): 
    for an output  Ì„x âˆˆ X âŠ† Fq^m
    compute  Ì„y âˆˆ Y such that F ( Ì„y) =  Ì„x; 
    The proof Ï€ is empty.

    Verify((q, F ),  Ì„x,  Ì„y, Ï€) 
    outputs Yes if F ( Ì„y) =  Ì„x.
